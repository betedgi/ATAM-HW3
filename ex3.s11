.=torg +2000
TIE = 25
WIN = 1
LOSE = 111111111111111111
NOMOV = 30
NOVAL = 40
NIL = 50

main:
		mov #main, sp;
		mov #WinParam, -(sp)
	  mov #DstPos, -(sp)
	  mov #SrcPos, -(sp)
		mov #-20, WinParam
		jsr pc, getMaxWP
		clr (sp)+
		clr (sp)+
		clr (sp)+
		halt

;~~~~~~~~~~~~~~~~~~~~~STACK-for getMaxWP~~~~~~~~~~~~~~~~~~~~~~~~~
;0-return address
;2-address for SrcPos
;4-address for DstPos
;6-address for WinParam
getMaxWP:
				clr -(sp)
				clr -(sp)
			  mov #NOVAL, -(sp)
				clr -(sp)
				mov Player, currPlr
				jsr pc, findMv  ; ||WP|| Win Parameter || source || dest||return address|| srcPos|| DstPos || WinParam
				mov (sp), @16(sp)
				mov 4(sp), @12(sp)
				mov 6(sp), @14(sp)
				clr (sp)+
				clr (sp)+
				clr (sp)+
				clr (sp)+
				rts pc
;~~~~~~~~~~~~~~~~~~~~STACK-for edge cases~~~~~~~~~~~~~~~~~~~~~~~~
;0-return address
;2-best WP
;4-best Win Parameter-win, lose ,tie
;6-best source
;10-best dest
edgCas:
				mov #Board, -(sp)
				mov currPlr, -(sp)
				cmp 4(sp), #TIE
				beq ACalcWP
				clr (sp)+
				clr (sp)+
				cmp 4(sp), #NOMOV
				beq nomovE
				mov currPlr, -(sp)
				mov #Player, -(sp)
				jsr pc, minOrMax
				clr (sp)+
				clr (sp)+
				cmp r4, #1
				bne rtnRevE
				rts pc

rtnRevE:
			neg 2(sp)
			neg 4(sp)
			rts pc

nomovE:
			mov #NOVAL, 4(sp) ;moves no value to Win parameter
			jsr pc, recur ;game has no moves so doing nothing is the only choice
			rts pc	;returns from the recursion becuase this son has nothing else to offer
;~~~~~~~~~~~~~~~~~~~~STACK-for hasMoves~~~~~~~~~~~~~~~~~~~~~~~~~
;0-return adress
;2-current player
;4-address of board
;6-return adress for recursion
;10-best WP
;12-best win Parameter
;14-best source
;16-best destination
hasMoves: ;works
			mov r0,-(sp) ;r0||return address|| return address||current player||address board
			mov r1,-(sp) ;r1||r0||return address|| return address||current player||address board
			mov #1, -(sp) ;2||r1||r0||return address|| return address||current player||address board
			clr -(sp) ;empty||2||r1||r0||return address|| return address||current player||address board
			jsr pc, numOmoves ;gets number of moves for current Player
			mov (sp), r0
			jsr pc, cngPlayer
			jsr pc, numOmoves ;gets number of moves for current rival
			mov (sp), r1
			jsr pc, cngPlayer
			clr (sp)+ ;2||r1||r0||return address|| return address||current player||address board
			clr (sp)+ ;r1||r0||return address|| return address||current player||address board
			cmp 0, r0
			beq isMv
			br ehasMv

isMv:
			mov #0, 14(sp)
			mov #NOMOV, 16(sp)
			mov #NIL, 20(sp)
			mov #NIL, 22(sp)
			br ehasMv

ehasMv:
			mov (sp)+, r1
			mov (sp)+, r0
			rts pc

;~~~~~~~~~~~~~~~~~~~~STACK-for CalcWP~~~~~~~~~~~~~~~~~~~~~~~~~
;0-current player
;2-address of board
;4-return adress
;6-best WP
;10-best win Parameter
;12-best source
;14-best destination
ACalcWP:
			jsr pc ,CalcWP
			cmp (sp), Player
			bne rtnRev

eACalcWP:
			mov r4, 6(sp)
			mov #0, 10(sp)
			mov #NIL, 12(sp)
			mov #NIL, 14(sp)
			clr (sp)+
			clr (sp)+
			rts pc

rtnRev:
			neg r4
			br eACalcWP


CalcWP:
			mov r0,-(sp) ;r0||return address||return address||current player||address board
			mov r1,-(sp) ;r1||r0||return address||return address||current player||address board
			mov #1, -(sp) ;1||r1||r0||return address||return address||current player||address board
			clr -(sp) ;empty||1||r1||r0||return address||return address||current player||address board
			jsr pc, numOmoves ;gets number of pieces for current Player
			mov (sp), r0
			jsr pc, cngPlayer
			jsr pc, numOmoves ;gets number of pieces for current rival
			mov (sp), r1
			jsr pc, cngPlayer
			clr (sp)+ ;1||r1||r0||return address||return address||current player||address board
			clr (sp)+ ;r1||r0||return address||return address||current player||address board
			sub r1, r0
			mov r0, r4
			mov (sp)+, r1 ;r0||return address||return address||current player||address board
			mov (sp)+, r0 ;return address||return address||current player||address board
			rts pc

;~~~~~~~~~~~~~~~~~~~~STACK-for checkWin~~~~~~~~~~~~~~~~~~~~~~~~~
;0-return adress
;2-current player
;4-address of board
;6-return address for recursion
;10-best WP
;12-best win Parameter
;14-best source
;16-best destination
checkWin:;works
			mov r0,-(sp) ;r0||return address|| return address||current player||address board
			mov r1,-(sp) ;r1||r0||return address|| return address||current player||address board
			mov #2, -(sp) ;2||r1||r0||return address|| return address||current player||address board
			clr -(sp) ;empty||2||r||r0||return address|| return address||current player||address board
			jsr pc, numOmoves ;gets number of pieces for current Player
			mov (sp), r0
			jsr pc, cngPlayer
			jsr pc, numOmoves ;gets number of pieces for current rival
			mov (sp), r1
			jsr pc, cngPlayer
			clr (sp)+ ;2||r2||r0||return address|| return address||current player||address board
			clr (sp)+ ;r2||r0||return address|| return address||current player||address board
			cmp r1, #0
			beq isWin
			cmp r0, #0
			beq isLose
			mov r2,-(sp) ;r2||r2||r0||return address|| return address||current player||address board
			mov #1, -(sp) ;1||r2||r1||r0||return address|| return address||current player||address board
			clr -(sp) ;empty||1||r2||r1||r0||return address|| return address||current player||address board
			jsr pc, numOmoves ;gets number of moves for current Player
			mov (sp), r2
			jsr pc, cngPlayer
			jsr pc, numOmoves ;gets number of moves for current rival
			add (sp), r2
			jsr pc, cngPlayer
			clr (sp)+ ;1||r2||r1||r0||return address|| return address||current player||address board
			clr (sp)+ ;r2||r1||r0||return address|| return address||current player||address board
			cmp 0, r2
			beq isTie
			mov (sp)+, r2
			br eChckWin

isWin:
			mov #20, 14(sp)
			mov #WIN, 16(sp)
			mov #NIL, 20(sp)
			mov #NIL, 22(sp)
			br eChckWin
isLose:
			mov #-20, 14(sp)
			mov #LOSE, 16(sp)
			mov #NIL, 20(sp)
			mov #NIL, 22(sp)
			br eChckWin

isTie:
			mov (sp)+, r2
			mov #0, 14(sp)
			mov #TIE, 16(sp)
			mov #NIL, 20(sp)
			mov #NIL, 22(sp)
			br eChckWin

eChckWin:
			mov (sp)+, r1
			mov (sp)+, r0
			rts pc

;~~~~~~~~~~~~~~~~~~~~STACK-for minOrMax~~~~~~~~~~~~~~~~~~~~~~~
;0-return adress
;2-address of Player
;4-current player
;return 1 if the player is the current player and -1 for the rival
minOrMax:
			mov #1, r4 ;insert default value to register
			mov @2(sp),r2 ;moves the value of Player to register 2
			mov 4(sp),r3 ;moves the value of current Player to register 2
			cmp r2, r3 ;check if the value is the same
			beq eminOMax
	    neg r4 ;if not negate the value of register 4 and returns it
			br eminOMax

eminOMax:
			rts pc



;~~~~~~~~~~~~~~~~~~~~STACK-for movPiece~~~~~~~~~~~~~~~~~~~~~~~
;0-return adress
;2-address Of Board
movPiece:
			mov (r5)+, r1 ;gets desination
			mov (r5)+, r0 ;gets source
			add 2(sp), r1 ;moves to the address of destination
			add 2(sp), r0 ;moves to the address of source
			mov (r0), (r1)
			sub 2(sp), r1 ;returns destination to original value
			mov #0, (r0)
			sub 2(sp), r0 ;returns source to original value
			mov r1, r2 ;checks if a piece was eaten
			sub r0, r2 ;checks if a piece was eaten
			cmp r2, #20 ;checks if a piece was eaten
			blos emPiece ;checks if a piece was eaten
			mov r0, r2 ;clears the piece's position if it was eaten
			add r1, r2 ;clears the piece's position if it was eaten
			div #2, r2 ;clears the piece's position if it was eaten
			add 2(sp), r2 ;clears the piece's position if it was eaten
			clr (r2) ;clears the piece's position if it was eaten

emPiece:
			rts r5

;~~~~~~~~~~~~~~~~~~~~STACK-for reverse movPiece~~~~~~~~~~~~~~~~~~~~~~~
;0-return adress
;2-address Of Board
RmovPiece:
			mov (r5)+, r1 ;gets desination
			mov (r5)+, r0 ;gets source
			add 2(sp), r1 ;moves to the address of destination
			add 2(sp), r0 ;moves to the address of source
			mov (r0), (r1)
			sub 2(sp), r1 ;returns destination to original value
			mov #0, (r0)
			sub 2(sp), r0 ;returns source to original value
			mov r0, r2 ;checks if a piece was eaten
			sub r1, r2 ;checks if a piece was eaten
			cmp r2, #20 ;checks if a piece was eaten
			blos RemPiece ;checks if a piece was eaten
			mov r0, r2 ;returns the piece that was eaten
			add r1, r2 ;returns the piece that was eaten
			div #2, r2 ;returns the piece that was eaten
			add 2(sp), r2 ;returns the piece that was eaten
			add 2(sp), r1 ;moves to the address of destination
			mov (r1), -(sp) ;gets the color of piece
			jsr pc, cngClr ;returns the piece that was eaten
			mov (sp)+, (r2) ;returns the piece that was eaten
			sub 2(sp), r1 ;returns destination to original value
			clr (sp)+

RemPiece:
			rts r5

;~~~~~~~~~~~~~~~~~~~~~STACK-for cmpWP~~~~~~~~~~~~~~~~~~~~~~
;todo-check if right
;0-return address to get results
;2-current wp
;4-current win param
;6-current source
;10-current dest
;12-dest done
;14-source done
;16-r5
;20-r4
;22-r3
;24-r1
;26-return address for function action
;30-return address to recursion
;32-best WP
;34-best Win Parameter
;36-best source
;40-best dest
cprWP:
			cmp 34(sp), #NOVAL
			beq cngVal
			cmp 2(sp), #1
			beq cngVal
			cmp 2(sp), #-1
			beq ecmpWP
			mov currPlr, -(sp)
			mov #Player, -(sp)
			jsr pc, minOrMax
			clr (sp)+
			clr (sp)+
			cmp r4, #-1
			beq chkLow
			br chkHig

ecmpWP:
	  	mov (sp), 10(sp)
			clr (sp)+
			clr (sp)+
			clr (sp)+
			clr (sp)+
			rts pc

chkHig:
			cmp 32(sp),2(sp)
			blt cngVal
			br ecmpWP

chkLow:
			cmp 32(sp),2(sp)
			bge cngVal
			br ecmpWP
;todo-make it work with n level and win cases
cngVal:
			mov 2(sp), 32(sp)
			mov 4(sp), 34(sp)
			mov 14(sp), 36(sp)
			mov 12(sp), 40(sp)
			br ecmpWP


;~~~~~~~~~~~~~~~~~~~~~STACK-for recursion~~~~~~~~~~~~~~~~~~~~~~
;0-return address
;2-best WP
;4-best Win Parameter-win, lose ,tie
;6-best source
;10-best dest

JedgCas:
			jmp edgCas
JACalcWP:
			jmp ACalcWP

findMv:
			mov #0, funUse
	 	  clr r0 ;source Initialization to 0
			clr r1
			clr r2 ;destination Initialization to 0
			clr r3 ;i index Initialization to 0
			clr r4 ;temporary position for eating Initialization to 0
			clr r5 ;j index Initialization to 0
			mov #Board, -(sp)
			mov currPlr, -(sp)
			jsr pc, checkWin
			clr (sp)+
			clr (sp)+
			cmp 4(sp), #NOVAL
			bne JedgCas;todo-edge case function for lose win tie and player has no moves
			mov #Board, -(sp)
			mov currPlr, -(sp)
			jsr pc, hasMoves
			clr (sp)+
			clr (sp)+
			cmp 4(sp), #NOVAL
			bne JedgCas;todo-edge case function for lose win tie and player has no moves
			;todo-edge case return value by actual Player win-lose
			mov #Board, -(sp)
			mov currPlr, -(sp)
			cmp Steps, #0
			beq JACalcWP
			clr (sp)+
			clr (sp)+
			br startMv


;~~~~~~~~~~~~~~~~~~~~STACK-for finding number of moves or pieces~~~~~~~~~~
			;0-return address
			;2-num Of moves or pieces
			;4-thing to do

numOmoves:
	    mov 4(sp), funUse
			mov r0, -(sp)
			mov r1, -(sp)
			mov r2, -(sp)
			mov r3, -(sp)
			mov r4, -(sp)
			mov r5, -(sp)
			clr r0 ;num of moves or num of Pieces Initialization to 0
			clr r1
			clr r2 ;Temporary position Initialization to 0
			clr r3 ;i index Initialization to 0
			clr r4 ;temporary position for eating Initialization to 0
			clr r5 ;j index Initialization to 0


;startMv - Updates the current position by the row and column index
;moves to a black or white label in accordance with the number of the player


startMv:
			mov r3, r2
			add r5, r2     ;current position
			cmp r2,#200
			bge JendcodeM
			cmp currPlr, #1 ;checks if player is one or two
			beq whtsMv
			br blksMv

JendcodeM:
			jmp endcodeM

JincPiec:
			jmp incPiec
;blksMv - Checks whether the current location has a black stone
;And the stone option to move left
blksMv:
			cmp Board(r2), #2 ;Checks whether the current location we are testing
			;has a stone of player number 2
			bne advncMv
			cmp funUse,#2 ;check if the function is counting pieces
			beq JincPiec
			cmp r2,#160 ;Checks whether the current location we are testing
			;is the last line for player 2
			bge endcodeM
			add #16,r2 ;A possible step of the stone
			cmp r3,#0 ;Checks if the stone is at the edge of the board
			;so this move is not possible
			beq blksMv2
			cmp Board(r2), #1 ;Checks if there is a stone of the other player at the position
			;which the stone could have moved to
			beq eblksMv
			cmp Board(r2), #2 ;Checks if there is a stone of the current player at the position
			;which the stone could have moved to
			beq blksMv2
			jsr pc ,funAct
			mov #0, r1
;blksMv2 - Checks the stone option to move right
blksMv2:
	 		add #4,r2 ;Another possible step of the stone
			cmp r3,#16 ;Checks if the stone is at the edge of the board
			;so this move is not possible
			beq advncMv
			cmp Board(r2),#1 ;Checks if there is a stone of the other player at the position
			;which the stone could have moved to
			beq eblksMv2
			cmp Board(r2),#2 ;Checks if there is a stone of the current player at the position
			;which the stone could have moved to
			beq advncMv
			jsr pc ,funAct
			mov #0, r1

;advncMv - Moves to the next position on the game board
advncMv:
			cmp r3,#16 ;Checks if the stone is at the edge of the board
			beq incrow
			add #2,r3 ;Moves to the next position on the board
			jmp startMv

;incrow - Moves to the beginning of the next line in the game board
incrow:
			clr r3 ;Move to the beginning of the line in the board
			add #20,r5 ;Move to the next  line in the board
			jmp startMv

;whtsMv - Checks whether the current location has a white stone
;And the stone option to move left
whtsMv:
			cmp Board(r2),#1; Checks whether the current location we are testing
			;has a stone of player number 1
			bne advncMv
			cmp funUse,#2 ;check if the function is counting pieces
			beq JincPiec
			cmp r2,#16 ;Checks whether the current location we are testing
			;is the last line for player 1
			ble advncMv
			cmp r2,#200 ;Checks whether the current location we are testing
			;is larger than the board boundaries
			bge endcodeM
			sub #16,r2 ;A possible step of the stone
			cmp r3,#16 ;Checks if the stone is at the edge of the board
			;so this move is not possible
			beq whtsMv2
			cmp Board(r2),#2 ;Checks if there is a stone of the other player at the position
			;which the stone could have moved to
			beq ewhtsMv
			cmp Board(r2),#1 ;Checks if there is a stone of the current player at the position
			;which the stone could have moved to
			beq whtsMv2
			jsr pc ,funAct
			mov #0, r1

;whtsMv2 - Checks the stone option to move right
whtsMv2:
	 		sub #4,r2 ;Another possible step of the stone
			cmp r3,#0 ;Checks if the stone is at the edge of the board
			beq advncMv
			cmp Board(r2),#2 ;Checks if there is a stone of the other player at the position
			;which the stone could have moved to
			beq ewhtsMv2
			cmp Board(r2),#1 ;Checks if there is a stone of the current player at the position
			;which the stone could have moved to
			beq advncMv
			jsr pc ,funAct
			mov #0, r1
			jmp advncMv

;eblksMv - Checks whether a black stone has the possibility to e in the left direction
eblksMv:
	  	cmp r3,#2 ;Checks if the stone is at the one step before thr edge of the board
			;So the stone can not e the stone of the opposing player at the edge of the board
			beq blksMv2
			cmp r5,#140 ;Checks whether the stone is in one line before the last on the board
			;So the stone can not e the stone of the opposing player at the end of the board
			bge blksMv2
			mov r2,r4 ;Temporary position
			add #16,r2
			cmp Board(r2),#0 ;Checks whether the place is empty one step further
			bne blksMv2
			jsr pc ,funAct
			mov #0, r1
			mov r4, r2
			jmp blksMv2



;endcodeM - Returns the number of possible steps and finishes the program
endcodeM:
			cmp funUse, #0
			beq ecodeM
			mov #0, funUse
			mov (sp)+, r5
			mov (sp)+, r4
   		mov (sp)+, r3
			mov (sp)+, r2
			mov (sp)+, r1
			mov r0 ,4(sp)
			mov (sp)+, r0


ecodeM: rts pc
;eblksMv2 - Checks whether a black stone has the possibility to e in the right direction
eblksMv2:
			cmp r3,#14 ;Checks if the stone is at the one step before thr edge of the board
			;So the stone can not e the stone of the opposing player at the edge of the board
			beq advncMv
			cmp r5,#140 ;Checks whether the stone is in one line before the last on the board
			;So the stone can not e the stone of the opposing player at the end of the board
			bge advncMv
			mov r2,r4 ;Temporary position
			add #22,r2
			cmp Board(r2),#0 ;Checks whether the place is empty one step further
			bne advncMv
			jsr pc ,funAct
			mov #0, r1
			mov r4, r2
			jmp advncMv

JadvncMv:
			jmp advncMv

;ewhtsMv - Checks whether a white stone has the possibility to e in the left direction
ewhtsMv:
			cmp r3,#14 ;Checks if the stone is at the one step before thr edge of the board
			;So the stone can not e the stone of the opposing player at the edge of the board
			beq whtsMv2
			cmp r5,#36 ;Checks whether the stone is in one line before the last on the board
			;So the stone can not e the stone of the opposing player at the end of the board
			ble whtsMv2
			mov r2,r4 ;Temporary position
			sub #16,r2
			cmp Board(r2),#0 ;Checks whether the place is empty one step further
			bne whtsMv2
			jsr pc ,funAct
			mov #0, r1
			mov r4, r2
			jmp whtsMv2

;ewhtsMv2 - Checks whether a white stone has the possibility to e in the right direction
ewhtsMv2:
			cmp r3,#2 ;Checks if the stone is at the one step before thr edge of the board
			;So the stone can not e the stone of the opposing player at the edge of the board
			beq JadvncMv
			cmp r5,#36 ;Checks whether the stone is in one line before the last on the board
			;So the stone can not e the stone of the opposing player at the end of the board
			ble JadvncMv
			mov r2,r4 ;Temporary position
			sub #22,r2
			cmp Board(r2),#0 ;Checks whether the place is empty one step further
			bne JadvncMv
			jsr pc ,funAct
			mov #0, r1
			mov r4, r2
			jmp advncMv

incPiec:
			inc r0
			jmp advncMv

funAct:
			cmp #1, funUse ;Adds the step to the number of possible steps
			beq stepsAdd ;branch to label which increases steps
			br recur ;branch to label which perfumes recursion

stepsAdd:
			inc r0
			rts pc


;~~~~~~~~~~~~~~~~~~~~~STACK-for recursion~~~~~~~~~~~~~~~~~~~~~~
;0-return address for function action
;2-return address for recursion
;4-best WP
;6-best Win Parameter-win, lose ,tie
;10-best source
;12-best dest
recur:
			mov r3, r0
			add r5, r0
			mov r1, -(sp)	;r1||return address||return address|| best WP||best Win Parameter|| best source || best dest
			mov r3, -(sp)	;r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov r4,-(sp) 	;r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov r5,-(sp) 	;r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov r0, -(sp) ;r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov r2, -(sp)	;r2||r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp), dest1 ;move pieces on board
			mov 2(sp), source1 ;move pieces on board
			mov #Board, -(sp)
			jsr r5, movPiece ;move pieces on board
			dest1: .blkw 1 ;move pieces on board
			source1: .blkw 1 ;move pieces on board
			clr (sp)+
			clr -(sp) ;dest||r2||r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			clr -(sp) ;source||dest||r2||r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov #NOVAL, -(sp) ;win param||source||dest||r2||r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			clr  -(sp) ;wp||win param||source||dest||r2||r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			jsr pc, cngPlayer
			dec Steps ;decreases the number of steps remaining
			jsr pc, findMv
			inc Steps ;increases the number of steps remaining
			jsr pc, cngPlayer
			jsr pc, cprWP
			mov 2(sp) ,-(sp) ;r0||r2||r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp), dest2
			mov 2(sp), source2
			mov #Board, -(sp)
			jsr r5, RmovPiece
			dest2: .blkw 1
			source2: .blkw 1
			clr (sp)+
			clr (sp)+ ;r2||r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp)+, r2 ;r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp)+, r0 ;r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp)+, r5 ;r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp)+, r4 ;r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp)+, r3 ;r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp)+, r1 ;return address|| return address|| best WP||best Win Parameter|| best source || best dest
			rts pc

;~~~~~~~~~~~~~~~~~~~~STACK-for change Player~~~~~~~~~~
;0-return address
cngPlayer:
			mov #3, -(sp) ;change player
			sub currPlr ,(sp) ;change player
			mov (sp)+, currPlr ;change player
			rts pc

funUse: .blkw 1
	;0-if the fuction is recursion 1-if the function purpose is to find the number of moves 2-to find the number of pieces
currPlr: .blkw 1

;~~~~~~~~~~~~~~~~~~~STACK-for reverse Colors~~~~~~~~~~~~
;0-return address
;2-color
cngClr:
			mov #3, -(sp) ;change color
			sub 4(sp) ,(sp) ;change color
			mov (sp), 4(sp) ;change color
			clr (sp)+
			rts pc
;~~~~~~~~~~~~~~~~~~~~~~~Input Label~~~~~~~~~~~~~~~~~~~~~

.=torg+11000
Board:	.word	0, 0, 0, 0, 0, 0, 0, 0
				.word	0, 0, 0, 0, 0, 0, 0, 0
				.word	0, 0, 0, 0, 0, 0, 0, 0
				.word	0, 0, 2, 0, 0, 0, 0, 0
				.word	0, 0, 0, 1, 0, 0, 0, 0
				.word	0, 0, 0, 0, 1, 0, 0, 0
				.word	0, 0, 0, 0, 0, 0, 0, 0
				.word	0, 0, 0, 0, 0, 0, 0, 0
Player:	.word	1
Steps:  .word   2

;output
SrcPos: .blkw 1
DstPos: .blkw 1
WinParam: .blkw 1
