.=torg +2000
TIE = 25
WIN = 1
LOSE = -1
NOMOV = 30
NOVAL = 40
NIL = -30



main:
;~~~~~~~~~~~~~~~~~~~~STACK-for hasMoves~~~~~~~~~~~~~~~~~~~~~~~~~
;0-return adress
;2-current player
;4-address of board
;6-best WP
;10-best win Parameter
;12-best source
;14-best destination
hasMoves:
			mov r0,-(sp) ;r0||return address||current player||address board
			mov r1,-(sp) ;r1||r0||return address||current player||address board
			mov #2, -(sp) ;2||r1||r0||return address||current player||address board
			clr -(sp) ;empty||2||r1||r0||return address||current player||address board
			jsr pc, numOmoves ;gets number of moves for current Player
			mov (sp), r0
			jsr pc, cngPlayer
			jsr pc, numOmoves ;gets number of moves for current rival
			mov (sp), r1
			jsr pc, cngPlayer
			clr (sp)+ ;2||r1||r0||return address||current player||address board
			clr (sp)+ ;r1||r0||return address||current player||address board
			cmp 0, r0
			beq isMv
			mov #0, 12(sp)
			mov #0, 14(sp)
			br ehasMv

isMv:
			mov #0, 12(sp)
			mov NOMOV, 14(sp)
			mov NIL, 16(sp)
			mov NIL, 18(sp)
			br ehasMv

ehasMv:
			mov (sp)+, r1
			mov (sp)+, r0
			rts pc
;~~~~~~~~~~~~~~~~~~~~STACK-for checkWin~~~~~~~~~~~~~~~~~~~~~~~~~
;0-return adress
;2-current player
;4-address of board
;6-best WP
;10-best win Parameter
;12-best source
;14-best destination
checkWin:
			mov r0,-(sp) ;r0||return address||current player||address board
			mov r1,-(sp) ;r1||r0||return address||current player||address board
			mov #1, -(sp) ;1||r1||r0||return address||current player||address board
			clr -(sp) ;empty||1||r1||r0||return address||current player||address board
			jsr pc, numOmoves ;gets number of pieces for current Player
			mov (sp), r0
			jsr pc, cngPlayer
			jsr pc, numOmoves ;gets number of pieces for current rival
			mov (sp), r1
			jsr pc, cngPlayer
			clr (sp)+ ;1||r1||r0||return address||current player||address board
			clr (sp)+ ;r1||r0||return address||current player||address board
			cmp r1, 0
			beq isWin
			cmp r0, 0
			beq isLose
			mov r2,-(sp) ;r2||r1||r0||return address||current player||address board
			mov #2, -(sp) ;1||r2||r1||r0||return address||current player||address board
			clr -(sp) ;empty||1||r2||r1||r0||return address||current player||address board
			jsr pc, numOmoves ;gets number of moves for current Player
			mov (sp), r2
			jsr pc, cngPlayer
			jsr pc, numOmoves ;gets number of moves for current rival
			add (sp), r2
			jsr pc, cngPlayer
			clr (sp)+ ;1||r2||r1||r0||return address||current player||address board
			clr (sp)+ ;r2||r1||r0||return address||current player||address board
			cmp 0, r2
			beq isTie
			mov #0, 12(sp)
			mov #0, 14(sp)
			br eChckWin

isWin:
			mov #20, 12(sp)
			mov WIN, 14(sp)
			mov NIL, 16(sp)
			mov NIL, 18(sp)
			br eChckWin
isLose:
			mov #-20, 12(sp)
			mov LOSE, 14(sp)
			mov NIL, 16(sp)
			mov NIL, 18(sp)
			br eChckWin

isTie:
			mov (sp)+, r2
			mov #0, 12(sp)
			mov TIE, 14(sp)
			mov NIL, 16(sp)
			mov NIL, 18(sp)
			br eChckWin

eChckWin:
			mov (sp)+, r1
			mov (sp)+, r0
			rts pc

;~~~~~~~~~~~~~~~~~~~~STACK-for minOrMax~~~~~~~~~~~~~~~~~~~~~~~
;0-return adress
;2-address of Player
;4-current player
;return 1 if the player is the current player and -1 for the rival
minOrMax:
			mov #1, r4 ;insert default value to register
			mov @2(sp),r2 ;moves the value of Player to register 2
			mov 4(sp),r3 ;moves the value of current Player to register 2
			cmp r2, r3 ;check if the value is the same
			beq eminOMax
	    neg r4 ;if not negate the value of register 4 and returns it
			br eminOMax

eminOMax:
			rts pc



;~~~~~~~~~~~~~~~~~~~~STACK-for movPiece~~~~~~~~~~~~~~~~~~~~~~~
;0-return adress
;2-address Of Board
movPiece:
			mov @(r5)+, r1 ;gets desination
			mov @(r5)+, r0 ;gets source
			add 2(sp), r1 ;moves to the address of destination
			add 2(sp), r0 ;moves to the address of source
			mov @(r0), @(r1)
			sub 2(sp), r1 ;returns destination to original value
			mov #0, @(r0)
			sub 2(sp), r0 ;returns source to original value
			mov r1, r2 ;checks if a piece was eaten
			sub r0, r2 ;checks if a piece was eaten
			cmp r2, #20 ;checks if a piece was eaten
			blos emPiece ;checks if a piece was eaten
			mov r0, r2 ;clears the piece's position if it was eaten
			add r1, r2 ;clears the piece's position if it was eaten
			div #2, r2 ;clears the piece's position if it was eaten
			add 2(sp), r2 ;clears the piece's position if it was eaten
			clr @(r2) ;clears the piece's position if it was eaten

emPiece:
			rts r5

;~~~~~~~~~~~~~~~~~~~~STACK-for reverse movPiece~~~~~~~~~~~~~~~~~~~~~~~
;0-return adress
;2-address Of Board
RmovPiece:
			mov @(r5)+, r1 ;gets desination
			mov @(r5)+, r0 ;gets source
			add 2(sp), r1 ;moves to the address of destination
			add 2(sp), r0 ;moves to the address of source
			mov @(r0), @(r1)
			sub 2(sp), r1 ;returns destination to original value
			mov #0, @(r0)
			sub 2(sp), r0 ;returns source to original value
			mov r0, r2 ;checks if a piece was eaten
			sub r1, r2 ;checks if a piece was eaten
			cmp r2, #20 ;checks if a piece was eaten
			blos RemPiece ;checks if a piece was eaten
			mov r0, r2 ;returns the piece that was eaten
			add r1, r2 ;returns the piece that was eaten
			div #2, r2 ;returns the piece that was eaten
			add 2(sp), r2 ;returns the piece that was eaten
			add 2(sp), r1 ;moves to the address of destination
			mov @(r1), -(sp) ;gets the color of piece
			jsr pc, cngClr ;returns the piece that was eaten
			mov (sp), @(r2) ;returns the piece that was eaten
			sub 2(sp), r1 ;returns destination to original value
			clr (sp)+

RemPiece:
			rts r5

;~~~~~~~~~~~~~~~~~~~~~STACK-for cmpWP~~~~~~~~~~~~~~~~~~~~~~
;todo-check if right
;0-return address to get results
;2-current wp
;4-current win param
;6-current source
;10-current dest
;12-r2
;14-r0
;16-r5
;20-r4
;22-r3
;24-r1
;26-return address for function action
;30-return address to recursion
;32-best WP
;34-best Win Parameter
;36-best source
;40-best dest
cprWP:
			cmp 34(sp), NOVAL
			beq cngVal
			cmp 2(sp), #1
			beq cngVal
			cmp 2(sp), #-1
			beq ecmpWP
			mov currPlr, -(sp)
			mov #Player, -(sp)
			jsr pc, minOrMax
			clr (sp)+
			clr (sp)+
			cmp r4, #-1
			beq chkLow
			br chkHig

ecmpWp:
	  	mov (sp), 10(sp)
			clr -(sp)
			clr -(sp)
			clr -(sp)
			clr -(sp)
			rts pc

chkLow:
			cmp 32(sp),2(sp)
			blt cngVal
			br ecmpWP

chkLow:
			cmp 32(sp),2(sp)
			bge cngVal
			br ecmpWP
;todo-make it work with n level and win cases
cngVal:
			mov 2(sp), 32(sp)
			mov 4(sp), 34(sp)
			mov 6(sp), 36(sp)
			mov 10(sp), 40(sp)


;~~~~~~~~~~~~~~~~~~~~~STACK-for recursion~~~~~~~~~~~~~~~~~~~~~~
;0-return address
;2-best WP
;4-best Win Parameter-win, lose ,tie
;6-best source
;10-best dest

findMv:
			mov #0, funAct
	 	  clr r0 ;source Initialization to 0
			clr r1
			clr r2 ;destination Initialization to 0
			clr r3 ;i index Initialization to 0
			clr r4 ;temporary position for eating Initialization to 0
			clr r5 ;j index Initialization to 0
			mov #Board, -(sp)
			mov currPlr, -(sp)
			jsr pc, checkWin
			cmp 4(sp), #0
			bne edgCas;todo-edge case function for lose win tie and player has no moves
			jsr pc, hasMoves
			cmp 4(sp), #0
			bne edgCas;todo-edge case function for lose win tie and player has no moves
			cmp Steps, #0
			beq CalcWP
			clr (sp)+
			clr (sp)+
			br startMv


;~~~~~~~~~~~~~~~~~~~~STACK-for finding number of moves or pieces~~~~~~~~~~
			;0-return address
			;2-num Of moves or pieces
			;4-thing to do

numOmoves:
	    mov 4(sp), funAct
			clr r0 ;num of moves or num of Pieces Initialization to 0
			clr r1
			clr r2 ;Temporary position Initialization to 0
			clr r3 ;i index Initialization to 0
			clr r4 ;temporary position for eating Initialization to 0
			clr r5 ;j index Initialization to 0


;startMv - Updates the current position by the row and column index
;moves to a black or white label in accordance with the number of the player
startMv:
			mov r3, r2
			add r5, r2     ;current position
			cmp currPlr, #1 ;checks if player is one or two
			beq whtsMv

;blksMv - Checks whether the current location has a black stone
;And the stone option to move left
blksMv:
			cmp Board(r2), #2 ;Checks whether the current location we are testing
			;has a stone of player number 2
			bne advncMv
			cmp funUse,#2 ;check if the function is counting pieces
			beq incPiec
			cmp r2,#160 ;Checks whether the current location we are testing
			;is the last line for player 2
			bge endcodeM
			add #16,r2 ;A possible step of the stone
			cmp r3,#0 ;Checks if the stone is at the edge of the board
			;so this move is not possible
			beq blksMv2
			cmp Board(r2), #1 ;Checks if there is a stone of the other player at the position
			;which the stone could have moved to
			beq eblksMv
			cmp Board(r2), #2 ;Checks if there is a stone of the current player at the position
			;which the stone could have moved to
			beq blksMv2
			jsr pc ,funAct
			mov #0, r1
;blksMv2 - Checks the stone option to move right
blksMv2:
	 		add #4,r2 ;Another possible step of the stone
			cmp r3,#16 ;Checks if the stone is at the edge of the board
			;so this move is not possible
			beq advncMv
			cmp Board(r2),#1 ;Checks if there is a stone of the other player at the position
			;which the stone could have moved to
			beq eblksMv2
			cmp Board(r2),#2 ;Checks if there is a stone of the current player at the position
			;which the stone could have moved to
			beq advncMv
			jsr pc ,funAct
			mov #0, r1

;advncMv - Moves to the next position on the game board
advncMv:
			cmp r3,#16 ;Checks if the stone is at the edge of the board
			beq incrow
			add #2,r3 ;Moves to the next position on the board
			jmp startMv

;incrow - Moves to the beginning of the next line in the game board
incrow:
			clr r3 ;Move to the beginning of the line in the board
			add #20,r5 ;Move to the next  line in the board
			jmp startMv

;whtsMv - Checks whether the current location has a white stone
;And the stone option to move left
whtsMv:
			cmp Board(r2),#1; Checks whether the current location we are testing
			;has a stone of player number 1
			bne advncMv
			cmp funUse,#2 ;check if the function is counting pieces
			beq incPiec
			cmp r2,#16 ;Checks whether the current location we are testing
			;is the last line for player 1
			ble advncMv
			cmp r2,#200 ;Checks whether the current location we are testing
			;is larger than the board boundaries
			bge endcodeM
			sub #16,r2 ;A possible step of the stone
			cmp r3,#16 ;Checks if the stone is at the edge of the board
			;so this move is not possible
			beq whtsMv2
			cmp Board(r2),#2 ;Checks if there is a stone of the other player at the position
			;which the stone could have moved to
			beq ewhtsMv
			cmp Board(r2),#1 ;Checks if there is a stone of the current player at the position
			;which the stone could have moved to
			beq whtsMv2
			jsr pc ,funAct
			mov #0, r1

;whtsMv2 - Checks the stone option to move right
whtsMv2:
	 		sub #4,r2 ;Another possible step of the stone
			cmp r3,#0 ;Checks if the stone is at the edge of the board
			beq advncMv
			cmp Board(r2),#2 ;Checks if there is a stone of the other player at the position
			;which the stone could have moved to
			beq ewhtsMv2
			cmp Board(r2),#1 ;Checks if there is a stone of the current player at the position
			;which the stone could have moved to
			beq advncMv
			jsr pc ,funAct
			mov #0, r1
			jmp advncMv

;eblksMv - Checks whether a black stone has the possibility to e in the left direction
eblksMv:
	  	cmp r3,#2 ;Checks if the stone is at the one step before thr edge of the board
			;So the stone can not e the stone of the opposing player at the edge of the board
			beq blksMv2
			cmp r5,#140 ;Checks whether the stone is in one line before the last on the board
			;So the stone can not e the stone of the opposing player at the end of the board
			bge blksMv2
			mov r2,r4 ;Temporary position
			add #16,r4
			cmp Board(r4),#0 ;Checks whether the place is empty one step further
			bne blksMv2
			jsr pc ,funAct
			mov #0, r1
			jmp blksMv2



;endcodeM - Returns the number of possible steps and finishes the program
endcodeM:
			cmp funUse, #0
			beq ecodeM
			mov r0 ,2(sp)

ecodeM: rts pc
;eblksMv2 - Checks whether a black stone has the possibility to e in the right direction
eblksMv2:
			cmp r3,#14 ;Checks if the stone is at the one step before thr edge of the board
			;So the stone can not e the stone of the opposing player at the edge of the board
			beq advncMv
			cmp r5,#140 ;Checks whether the stone is in one line before the last on the board
			;So the stone can not e the stone of the opposing player at the end of the board
			bge advncMv
			mov r2,r4 ;Temporary position
			add #22,r4
			cmp Board(r4),#0 ;Checks whether the place is empty one step further
			bne advncMv
			jsr pc ,funAct
			mov #0, r1
			jmp advncMv

;ewhtsMv - Checks whether a white stone has the possibility to e in the left direction
ewhtsMv:
			cmp r3,#14 ;Checks if the stone is at the one step before thr edge of the board
			;So the stone can not e the stone of the opposing player at the edge of the board
			beq whtsMv2
			cmp r5,#36 ;Checks whether the stone is in one line before the last on the board
			;So the stone can not e the stone of the opposing player at the end of the board
			ble whtsMv2
			mov r2,r4 ;Temporary position
			sub #16,r4
			cmp Board(r4),#0 ;Checks whether the place is empty one step further
			bne whtsMv2
			jsr pc ,funAct
			mov #0, r1
			jmp whtsMv2

;ewhtsMv2 - Checks whether a white stone has the possibility to e in the right direction
ewhtsMv2:
			cmp r3,#2 ;Checks if the stone is at the one step before thr edge of the board
			;So the stone can not e the stone of the opposing player at the edge of the board
			beq advncMv
			cmp r5,#36 ;Checks whether the stone is in one line before the last on the board
			;So the stone can not e the stone of the opposing player at the end of the board
			ble advncMv
			mov r2,r4 ;Temporary position
			sub #22,r4
			cmp Board(r4),#0 ;Checks whether the place is empty one step further
			bne advncMv
			jsr pc ,funAct
			mov #0, r1
			jmp advncMv

incPiec:
			inc r0
			jmp advncMv

funAct:
			cmp #1, funUse ;Adds the step to the number of possible steps
			beq stepsAdd ;branch to label which increases steps
			br recur ;branch to label which perfumes recursion

stepsAdd:
			inc r0
			rts pc


;~~~~~~~~~~~~~~~~~~~~~STACK-for recursion~~~~~~~~~~~~~~~~~~~~~~
;0-return address for function action
;2-return address for recursion
;4-best WP
;6-best Win Parameter-win, lose ,tie
;10-best source
;12-best dest
recur:
			mov r3, r0
			add r5, r0
			mov r1, -(sp)	;r1||return address||return address|| best WP||best Win Parameter|| best source || best dest
			mov r3, -(sp)	;r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov r4,-(sp) 	;r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov r5,-(sp) 	;r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov r0, -(sp) ;r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov r2, -(sp)	;r2||r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp), dest1 ;move pieces on board
			mov 2(sp), source1 ;move pieces on board
			jsr r5, movPiece ;move pieces on board
			dest1: .blkw 1 ;move pieces on board
			source1: .blkw 1 ;move pieces on board
			clr -(sp) ;dest||r2||r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			clr -(sp) ;source||dest||r2||r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov NOVAL, -(sp) ;win param||source||dest||r2||r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			clr  -(sp) ;wp||win param||source||dest||r2||r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			jsr pc, cngPlayer
			dec Steps ;decreases the number of steps remaining
			jsr pc, findMv
			inc Steps ;increases the number of steps remaining
			jsr pc, cngPlayer
			jsr pc, cprWP
			mov 2(sp) ,-(sp) ;r0||r2||r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov 2(sp), dest2
			mov 4(sp), source2
			jsr r5, RmovPiece
			dest2: .blkw 1
			source2: .blkw 1
			tst (sp)+ ;r2||r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp)+, r2 ;r0||r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp)+, r0 ;r5||r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp)+, r5 ;r4||r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp)+, r4 ;r3||r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp)+, r3 ;r1||return address|| return address|| best WP||best Win Parameter|| best source || best dest
			mov (sp)+, r1 ;return address|| return address|| best WP||best Win Parameter|| best source || best dest
			rts pc

;~~~~~~~~~~~~~~~~~~~~STACK-for change Player~~~~~~~~~~
;0-return address
cngPlayer:
			mov #3, -(sp) ;change player
			sub currPlr ,(sp) ;change player
			mov (sp)+, currPlr ;change player
			rts pc

funUse: .blkw 1
	;0-if the fuction is recursion 1-if the function purpose is to find the number of moves 2-to find the number of pieces
currPlr: .blkw 1

;~~~~~~~~~~~~~~~~~~~STACK-for reverse Colors~~~~~~~~~~~~
;0-return address
;2-color
cngClr:
			mov #3, -(sp) ;change color
			sub 4(sp) ,(sp) ;change color
			mov (sp), 4(sp) ;change color
			clr (sp)+
			rts pc
;~~~~~~~~~~~~~~~~~~~~~~~Input Label~~~~~~~~~~~~~~~~~~~~~

Board:
Steps:
Player:
